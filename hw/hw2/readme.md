# 可中途中断的树遍历
第五课中我们学习了二叉树。写了前、中、后序遍历。但是都是一次性遍历所有的节点。在日常的软件工程中，通常不用遍历所有的数据，遇到某些条件可以终止。

请写一个可以中途终止的遍历。有如下两种接口之一：
### 接口 1
```js
let tree = new Tree();

tree.traversal('pre/in/post', (element) => {
    ...
    return true/false
})
```
这里的遍历函数接受一个字符串表示哪种顺序，和一个匿名函数。每遍历一个节点就执行这个函数。如果函数返回 true 则继续执行。如果返回 false，则停止遍历。

### 接口 2
如果你对设计范式有一定的了解，那么，请将上面的实现改为迭代器。
```js
let tree = new Tree();
let iterTree = tree.iter('pre/in/post');    // 哪一种顺序
iterTree.next()     // 返回第一个节点
iterTree.next()     // 返回第第二个节点
iterTree.next()     // 如果已经没有新的节点可以遍历，那么请返回一个错误。取决于你使用的语言，可以选择抛出异常或者返回（数值，错误）对。
```

# 更快的快排
我们知道快排的时间复杂度为 O(n^2)，仅仅在有些情况可以满足 O(n * logn)。如果遇到刚好有序但是顺序相反的数组，那么就一定是 O(n^2)。

你能写出一个几乎总是 O(n * logn) 的快排实现吗？并且，你能解释为什么，明明都是 O(n * logn)，快排比归并排序快吗？

我会给出 Python 实现的基准版本快排O(n^2)。你可以将其翻译到自己的语言。

你需要实现一个明显比基准版快很多的快排。与往常上课不同，你不用非要用递归来写。

这道题的文字分析和代码实现同样重要。
